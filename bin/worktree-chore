#!/usr/bin/env bash
set -euo pipefail

# -------- config --------
PROTECTED_BRANCHES_REGEX='^(main|release)$'  # add master if needed: '^(main|release|master)$'
DRY_RUN=false
YES=false
AUTO_PULL=true
export GIT_PAGER=cat

usage() {
  cat <<'EOF'
Usage: worktree-cleanup.sh [--dry-run|-n] [--yes|-y] [--no-pull] [--help|-h]

Cleans up git worktrees:
- SAFE REMOVE: merged into origin/main|origin/release OR remote-tracking branch deleted
- BEHIND: can auto pull --rebase
- ATTENTION: uncommitted, unpushed, diverged
- KEEP: unique work

Options:
  -n, --dry-run   Show actions without changing anything
  -y, --yes       Do not ask for confirmation
  --no-pull       Do not auto pull behind branches
  -h, --help      Show help
EOF
}

# -------- args --------
while [[ $# -gt 0 ]]; do
  case "$1" in
    -n|--dry-run) DRY_RUN=true; shift ;;
    -y|--yes) YES=true; shift ;;
    --no-pull) AUTO_PULL=false; shift ;;
    -h|--help) usage; exit 0 ;;
    *) echo "Unknown option: $1"; usage; exit 1 ;;
  esac
done

# -------- preflight --------
if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
  echo "Error: run inside a git repository/worktree"
  exit 1
fi

repo_root="$(git rev-parse --show-toplevel 2>/dev/null || true)"
repo_cwd="$(pwd)"
status_file="$(mktemp -t worktree_cleanup.XXXXXX)"

cleanup() { rm -f "$status_file" 2>/dev/null || true; }
trap cleanup EXIT

echo "ðŸ§¹ worktree cleanup  (mode: $($DRY_RUN && echo DRY-RUN || echo LIVE))"

# -------- fetch --------
if $DRY_RUN; then
  git fetch --all --prune --dry-run >/dev/null 2>&1 || true
else
  git fetch --all --prune >/dev/null 2>&1 || true
fi

# -------- helper: list worktrees robustly --------
# Emits: path<TAB>branch_name (branch_name can be empty for detached)
list_worktrees() {
  git worktree list --porcelain |
    awk '
      $1=="worktree"{path=$2}
      $1=="bare"{path=""; next}
      $1=="branch"{
        b=$2
        sub("^refs/heads/","",b)
        sub("^refs/remotes/","",b)
        print path "\t" b
      }
      $1=="detached"{
        # detached HEAD; treat as attention
        print path "\t" "(detached)"
      }
    '
}

# -------- analyze --------
while IFS=$'\t' read -r wt_path wt_branch; do
  [[ -z "${wt_path:-}" ]] && continue
  [[ ! -d "$wt_path" ]] && continue

  # Enter worktree
  if ! cd "$wt_path" 2>/dev/null; then
    echo "$wt_path|$wt_branch|attention|unreadable" >>"$status_file"
    continue
  fi

  # Determine branch reliably
  branch="$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")"
  if [[ "$branch" == "HEAD" || -z "$branch" ]]; then
    echo "$wt_path|(detached)|attention|detached" >>"$status_file"
    cd "$repo_cwd" >/dev/null 2>&1 || true
    continue
  fi

  # Protected branches: keep
  if [[ "$branch" =~ $PROTECTED_BRANCHES_REGEX ]]; then
    echo "$wt_path|$branch|keep|protected" >>"$status_file"
    cd "$repo_cwd" >/dev/null 2>&1 || true
    continue
  fi

  # Uncommitted changes: attention
  if ! git diff-index --quiet HEAD -- 2>/dev/null; then
    echo "$wt_path|$branch|attention|uncommitted" >>"$status_file"
    cd "$repo_cwd" >/dev/null 2>&1 || true
    continue
  fi

  # If remote-tracking branch is missing locally, it was pruned/deleted => safe remove
  # (no slow ls-remote calls)
  if ! git show-ref --verify --quiet "refs/remotes/origin/$branch"; then
    echo "$wt_path|$branch|safe|remote_deleted" >>"$status_file"
    cd "$repo_cwd" >/dev/null 2>&1 || true
    continue
  fi

  # Ahead/behind relative to origin/branch
  ahead="$(git rev-list --count "origin/$branch..HEAD" 2>/dev/null || echo 0)"
  behind="$(git rev-list --count "HEAD..origin/$branch" 2>/dev/null || echo 0)"

  if [[ "$ahead" -gt 0 && "$behind" -gt 0 ]]; then
    echo "$wt_path|$branch|attention|diverged|$ahead|$behind" >>"$status_file"
    cd "$repo_cwd" >/dev/null 2>&1 || true
    continue
  elif [[ "$ahead" -gt 0 ]]; then
    echo "$wt_path|$branch|attention|unpushed|$ahead" >>"$status_file"
    cd "$repo_cwd" >/dev/null 2>&1 || true
    continue
  elif [[ "$behind" -gt 0 ]]; then
    echo "$wt_path|$branch|behind|behind|$behind" >>"$status_file"
    cd "$repo_cwd" >/dev/null 2>&1 || true
    continue
  fi

  # Merged into protected remote branches => safe
  merged_into=""
  for target in main release; do
    if git show-ref --verify --quiet "refs/remotes/origin/$target"; then
      if git merge-base --is-ancestor HEAD "origin/$target" 2>/dev/null; then
        merged_into="$target"
        break
      fi
    fi
  done

  if [[ -n "$merged_into" ]]; then
    echo "$wt_path|$branch|safe|merged|$merged_into" >>"$status_file"
  else
    echo "$wt_path|$branch|keep|unique" >>"$status_file"
  fi

  cd "$repo_cwd" >/dev/null 2>&1 || true
done < <(list_worktrees)

# -------- summarize (only important info) --------
safe="$(grep '|safe|' "$status_file" 2>/dev/null || true)"
behind_list="$(grep '|behind|' "$status_file" 2>/dev/null || true)"
attention="$(grep '|attention|' "$status_file" 2>/dev/null || true)"
keep="$(grep '|keep|' "$status_file" 2>/dev/null || true)"

echo

if [[ -n "$safe" ]]; then
  echo "âœ… SAFE TO REMOVE"
  echo "$safe" | while IFS='|' read -r path branch _ reason extra; do
    case "$reason" in
      remote_deleted) echo "  â€¢ $branch  (remote gone)";;
      merged) echo "  â€¢ $branch  (merged into origin/$extra)";;
      *) echo "  â€¢ $branch";;
    esac
    echo "    $path"
  done
  echo
fi

if [[ -n "$behind_list" ]]; then
  echo "ðŸ”„ BEHIND (can pull --rebase)"
  echo "$behind_list" | while IFS='|' read -r path branch _ _ count; do
    echo "  â€¢ $branch  ($count behind)"
    echo "    $path"
  done
  echo
fi

if [[ -n "$attention" ]]; then
  echo "âš ï¸  ATTENTION (manual review)"
  echo "$attention" | while IFS='|' read -r path branch _ reason a b; do
    case "$reason" in
      uncommitted) echo "  â€¢ $branch  (uncommitted changes)";;
      unpushed) echo "  â€¢ $branch  ($a unpushed)";;
      diverged) echo "  â€¢ $branch  (diverged: $a ahead, $b behind)";;
      detached) echo "  â€¢ (detached)";;
      unreadable) echo "  â€¢ $branch  (cannot read path)";;
      *) echo "  â€¢ $branch  ($reason)";;
    esac
    echo "    $path"
  done
  echo
fi

# keep is not printed by default (declutter), but you can uncomment if you want:
# if [[ -n "$keep" ]]; then
#   echo "â„¹ï¸  KEEP"
#   echo "$keep" | while IFS='|' read -r path branch _ why _; do
#     echo "  â€¢ $branch  ($why)"
#     echo "    $path"
#   done
#   echo
# fi

safe_count="$(printf "%s\n" "$safe" | sed '/^$/d' | wc -l | tr -d ' ')"
behind_count="$(printf "%s\n" "$behind_list" | sed '/^$/d' | wc -l | tr -d ' ')"

if [[ "$safe_count" -eq 0 && "$behind_count" -eq 0 ]]; then
  echo "âœ“ Nothing to do automatically."
  exit 0
fi

# -------- confirm --------
if ! $YES && ! $DRY_RUN; then
  echo "Ready to:"
  [[ "$safe_count" -gt 0 ]] && echo "  â€¢ remove $safe_count worktree(s)"
  [[ "$behind_count" -gt 0 ]] && $AUTO_PULL && echo "  â€¢ pull $behind_count worktree(s)"
  echo
  read -r -p "Proceed? [y/N] " ans
  [[ "$ans" =~ ^[Yy]([Ee][Ss])?$ ]] || { echo "Aborted."; exit 0; }
fi

# -------- actions --------
if [[ "$safe_count" -gt 0 ]]; then
  echo "ðŸ—‘ï¸  Removing safe worktrees..."
  printf "%s\n" "$safe" | sed '/^$/d' | while IFS='|' read -r path branch _ _ _; do
    if $DRY_RUN; then
      echo "  [DRY RUN] git worktree remove --force \"$path\""
      echo "  [DRY RUN] git branch -d \"$branch\""
      continue
    fi

    git worktree remove --force "$path" >/dev/null 2>&1 \
      && echo "  âœ“ removed $branch" \
      || echo "  âš ï¸  failed to remove $branch"

    # delete local branch if possible (will fail if not fully merged)
    git branch -d "$branch" >/dev/null 2>&1 || true
  done
  echo
fi

if [[ "$behind_count" -gt 0 && "$AUTO_PULL" == true ]]; then
  echo "â¬‡ï¸  Pulling behind worktrees..."
  printf "%s\n" "$behind_list" | sed '/^$/d' | while IFS='|' read -r path branch _ _ _; do
    if $DRY_RUN; then
      echo "  [DRY RUN] (cd \"$path\" && git pull --rebase)"
      continue
    fi

    if cd "$path" 2>/dev/null; then
      git pull --rebase >/dev/null 2>&1 \
        && echo "  âœ“ pulled $branch" \
        || echo "  âš ï¸  failed pull $branch"
      cd "$repo_cwd" >/dev/null 2>&1 || true
    else
      echo "  âš ï¸  cannot cd: $path"
    fi
  done
  echo
fi

# -------- prune --------
if $DRY_RUN; then
  echo "[DRY RUN] git worktree prune"
else
  git worktree prune >/dev/null 2>&1 || true
fi

echo "âœ“ Done."
