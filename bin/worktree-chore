#!/usr/bin/env bash

set -euo pipefail

# Configuration
PROTECTED_BRANCHES="^(main|release)$"
DRY_RUN=false
INTERACTIVE=true
AUTO_PULL=true
export GIT_PAGER=cat
STATUS_FILE="/tmp/worktree_cleanup_status.txt"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

usage() {
  cat << EOF
Usage: $0 [OPTIONS]

Clean up local Git worktrees and branches comprehensively.

OPTIONS:
  -n, --dry-run       Show what would be done without making changes
  -y, --yes           Skip confirmation prompts (auto-confirm)
  -h, --help          Show this help message

EXAMPLES:
  $0                  Interactive cleanup
  $0 -n               Dry run (show what would happen)
  $0 -y               Auto-confirm all actions
EOF
  exit 1
}

# Parse arguments
while [[ $# -gt 0 ]]; do
  case "$1" in
    -n|--dry-run)
      DRY_RUN=true
      shift
      ;;
    -y|--yes)
      INTERACTIVE=false
      shift
      ;;
    -h|--help)
      usage
      ;;
    *)
      echo "Unknown option: $1"
      usage
      ;;
  esac
done

echo "======================================"
echo "üßπ COMPREHENSIVE WORKTREE CLEANUP"
echo "======================================"
echo ""
echo "Mode: $([ "$DRY_RUN" = true ] && echo "DRY RUN" || echo "LIVE")"
echo "Interactive: $INTERACTIVE"
echo ""

# Preconditions and state reset
if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
  echo -e "${RED}Error: this command must be run inside a Git worktree${NC}"
  exit 1
fi

rm -f "$STATUS_FILE"
touch "$STATUS_FILE"

# Initialize tracking
declare -a SAFE_TO_REMOVE=()
declare -a NEEDS_ATTENTION=()
declare -a UNPUSHED=()
declare -a BEHIND=()
declare -a DIVERGED=()
declare -a UNCOMMITTED=()

# Step 1: Fetch all remotes
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "üì° STEP 1: Fetching from remote"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo ""
if [ "$DRY_RUN" = true ]; then
  if ! git fetch --all --prune --dry-run; then
    echo -e "${YELLOW}‚ö†Ô∏è  Fetch dry-run failed, continuing with local refs${NC}"
  fi
else
  if ! git fetch --all --prune; then
    echo -e "${YELLOW}‚ö†Ô∏è  Fetch failed, continuing with local refs${NC}"
  fi
fi
echo ""

# Step 2: Update protected branches
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "üîÑ STEP 2: Updating protected branches"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo ""

for main_branch in "main" "release"; do
  main_path=$(git worktree list | grep -E "\[$main_branch\]|\/$main_branch$" | awk '{print $1}' | head -1 || true)
  
  if [ -n "$main_path" ] && [ -d "$main_path" ]; then
    echo "Updating $main_branch at $main_path..."
    if [ "$DRY_RUN" = false ]; then
      cd "$main_path"
      if git diff-index --quiet HEAD -- 2>/dev/null; then
        git pull --rebase 2>&1 && echo "  ‚úì Updated" || echo "  ‚ö†Ô∏è  Failed to update"
      else
        echo "  ‚ö†Ô∏è  Has uncommitted changes, skipping update"
      fi
    else
      echo "  [DRY RUN] Would update"
    fi
  fi
done
echo ""

# Step 3: Analyze all worktrees
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "üîç STEP 3: Analyzing worktrees"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo ""

git worktree list | awk '{print $1}' | while read -r worktree_path; do
  cd "$worktree_path" 2>/dev/null || continue
  
  branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
  if [ -z "$branch" ]; then continue; fi
  
  # Skip protected branches
  if [[ "$branch" =~ $PROTECTED_BRANCHES ]]; then
    echo "‚úì $branch (protected)"
    continue
  fi
  
  echo "Checking: $branch"
  echo "  Path: $worktree_path"
  
  # Check for uncommitted changes
  if ! git diff-index --quiet HEAD -- 2>/dev/null; then
    echo "  ‚ö†Ô∏è  Uncommitted changes"
    echo "$worktree_path|$branch|uncommitted" >> "$STATUS_FILE"
    continue
  fi
  
  # Check if remote branch exists
  if ! git ls-remote --exit-code --heads origin "$branch" >/dev/null 2>&1; then
    echo "  üóëÔ∏è  Remote deleted (merged)"
    echo "$worktree_path|$branch|remote_deleted" >> "$STATUS_FILE"
    continue
  fi
  
  # Check sync status
  unpushed=$(git log origin/$branch..HEAD --oneline 2>/dev/null | wc -l | tr -d ' ')
  behind=$(git log HEAD..origin/$branch --oneline 2>/dev/null | wc -l | tr -d ' ')
  
  if [ "$unpushed" -gt 0 ] && [ "$behind" -gt 0 ]; then
    echo "  ‚ö†Ô∏è  Diverged: $unpushed ahead, $behind behind"
    echo "$worktree_path|$branch|diverged|$unpushed|$behind" >> "$STATUS_FILE"
    continue
  elif [ "$unpushed" -gt 0 ]; then
    echo "  ‚Üë $unpushed unpushed commits"
    echo "$worktree_path|$branch|unpushed|$unpushed" >> "$STATUS_FILE"
    continue
  elif [ "$behind" -gt 0 ]; then
    echo "  ‚Üì $behind commits behind"
    echo "$worktree_path|$branch|behind|$behind" >> "$STATUS_FILE"
    continue
  fi
  
  # Check if merged into any protected branch
  merged_into=""
  for target in "main" "release"; do
    if git merge-base --is-ancestor HEAD origin/$target 2>/dev/null; then
      merged_into="$target"
      break
    fi
  done
  
  if [ -n "$merged_into" ]; then
    echo "  ‚úì Merged into $merged_into"
    echo "$worktree_path|$branch|merged|$merged_into" >> "$STATUS_FILE"
  else
    echo "  ‚ÑπÔ∏è  Has unique work"
    echo "$worktree_path|$branch|unique" >> "$STATUS_FILE"
  fi
  
  echo ""
done

# Step 4: Summary and actions
echo ""
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "üìä STEP 4: Summary & Actions"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo ""

if [ ! -s "$STATUS_FILE" ]; then
  echo "‚úì All worktrees are clean!"
  rm -f "$STATUS_FILE"
  exit 0
fi

# Parse results
remote_deleted=$(grep "|remote_deleted$" "$STATUS_FILE" 2>/dev/null || true)
merged=$(grep "|merged|" "$STATUS_FILE" 2>/dev/null || true)
behind=$(grep "|behind|" "$STATUS_FILE" 2>/dev/null || true)
diverged=$(grep "|diverged|" "$STATUS_FILE" 2>/dev/null || true)
unpushed=$(grep "|unpushed|" "$STATUS_FILE" 2>/dev/null || true)
uncommitted=$(grep "|uncommitted$" "$STATUS_FILE" 2>/dev/null || true)
unique=$(grep "|unique$" "$STATUS_FILE" 2>/dev/null || true)

# Category 1: Safe to remove
if [ -n "$remote_deleted" ] || [ -n "$merged" ]; then
  echo -e "${GREEN}‚úÖ SAFE TO REMOVE${NC}"
  echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
  
  if [ -n "$remote_deleted" ]; then
    echo ""
    echo "Remote branch deleted (work is merged elsewhere):"
    echo "$remote_deleted" | while IFS='|' read path branch status; do
      echo "  ‚Ä¢ $branch"
      echo "    $path"
    done
  fi
  
  if [ -n "$merged" ]; then
    echo ""
    echo "Fully merged into protected branches:"
    echo "$merged" | while IFS='|' read path branch status target; do
      echo "  ‚Ä¢ $branch ‚Üí $target"
      echo "    $path"
    done
  fi
  echo ""
fi

# Category 2: Can be synced automatically
if [ -n "$behind" ]; then
  echo -e "${BLUE}üîÑ CAN BE SYNCED${NC}"
  echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
  echo ""
  echo "Behind remote (can be pulled):"
  echo "$behind" | while IFS='|' read path branch status count; do
    echo "  ‚Ä¢ $branch ($count commits behind)"
    echo "    $path"
  done
  echo ""
fi

# Category 3: Needs attention
if [ -n "$diverged" ] || [ -n "$unpushed" ] || [ -n "$uncommitted" ]; then
  echo -e "${YELLOW}‚ö†Ô∏è  NEEDS ATTENTION${NC}"
  echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
  
  if [ -n "$diverged" ]; then
    echo ""
    echo "Diverged (local and remote have different commits):"
    echo "$diverged" | while IFS='|' read path branch status ahead behind_count; do
      echo "  ‚Ä¢ $branch ($ahead ahead, $behind_count behind)"
      echo "    $path"
      echo "    ‚Üí Likely rebased in PR - review manually"
    done
  fi
  
  if [ -n "$unpushed" ]; then
    echo ""
    echo "Unpushed commits:"
    echo "$unpushed" | while IFS='|' read path branch status count; do
      echo "  ‚Ä¢ $branch ($count unpushed)"
      echo "    $path"
    done
  fi
  
  if [ -n "$uncommitted" ]; then
    echo ""
    echo "Uncommitted changes:"
    echo "$uncommitted" | while IFS='|' read path branch status; do
      echo "  ‚Ä¢ $branch"
      echo "    $path"
    done
  fi
  echo ""
fi

# Category 4: Keep (has unique work)
if [ -n "$unique" ]; then
  echo -e "${BLUE}‚ÑπÔ∏è  KEEP (has unique work)${NC}"
  echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
  echo ""
  echo "$unique" | while IFS='|' read path branch status; do
    echo "  ‚Ä¢ $branch"
    echo "    $path"
  done
  echo ""
fi

# Step 5: Execute cleanup
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "üéØ ACTIONS"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo ""

# Count items properly
removable_count=0
if [ -n "$remote_deleted" ]; then
  removable_count=$((removable_count + $(echo "$remote_deleted" | grep -c "^")))
fi
if [ -n "$merged" ]; then
  removable_count=$((removable_count + $(echo "$merged" | grep -c "^")))
fi

syncable_count=0
if [ -n "$behind" ]; then
  syncable_count=$(echo "$behind" | grep -c "^")
fi

if [ "$removable_count" -eq 0 ] && [ "$syncable_count" -eq 0 ]; then
  echo "‚úì Nothing to cleanup automatically"
  rm -f "$STATUS_FILE"
  exit 0
fi

echo "Ready to:"
[ "$removable_count" -gt 0 ] && echo "  ‚Ä¢ Remove $removable_count worktree(s)"
[ "$syncable_count" -gt 0 ] && echo "  ‚Ä¢ Sync $syncable_count worktree(s)"
echo ""

should_continue=true
if [ "$INTERACTIVE" = true ] && [ "$DRY_RUN" = false ]; then
  read -r -p "Proceed with these actions? [y/N] " response
  case "$response" in
    [Yy]|[Yy][Ee][Ss]) should_continue=true ;;
    *) should_continue=false ;;
  esac
fi

if [ "$should_continue" = false ]; then
  echo "Aborted by user."
  rm -f "$STATUS_FILE"
  exit 0
fi

repo_cwd="$(pwd)"
removed_ok=0
synced_ok=0

if [ "$removable_count" -gt 0 ]; then
  echo "Removing safe worktrees..."
  echo "$remote_deleted"$'\n'"$merged" | sed '/^$/d' | while IFS='|' read -r path branch status target; do
    if [ "$DRY_RUN" = true ]; then
      echo "  [DRY RUN] Would remove worktree: $path ($branch)"
      echo "  [DRY RUN] Would delete branch: $branch"
      continue
    fi

    if git worktree remove "$path"; then
      echo "  ‚úì Removed worktree: $path"
      if git branch -d "$branch" >/dev/null 2>&1; then
        echo "    ‚úì Deleted branch: $branch"
      else
        echo "    ‚ö†Ô∏è  Branch not deleted automatically: $branch"
      fi
    else
      echo "  ‚ö†Ô∏è  Failed to remove worktree: $path"
    fi
  done
fi

if [ "$syncable_count" -gt 0 ] && [ "$AUTO_PULL" = true ]; then
  echo "Syncing behind worktrees..."
  echo "$behind" | while IFS='|' read -r path branch status count; do
    if [ "$DRY_RUN" = true ]; then
      echo "  [DRY RUN] Would pull --rebase in: $path ($branch)"
      continue
    fi

    if cd "$path" 2>/dev/null; then
      if git pull --rebase; then
        echo "  ‚úì Synced: $branch"
      else
        echo "  ‚ö†Ô∏è  Failed to sync: $branch"
      fi
      cd "$repo_cwd" >/dev/null 2>&1 || true
    else
      echo "  ‚ö†Ô∏è  Worktree path unavailable: $path"
    fi
  done
fi

rm -f "$STATUS_FILE"

# vi:ft=sh:
